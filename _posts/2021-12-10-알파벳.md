---
layout: post
title:  "[백준 1987/Python] 알파벳"
author: YoungJoo
categories: [algorithm]
tags: [ algorithm ]
image: assets/images/백준.png
rating: 4.5
---

링크 - https://www.acmicpc.net/problem/1987
 
문제 - 세로 R칸, 가로 C칸으로 된 표 모양의 보드가 있다. 보드의 각 칸에는 대문자 알파벳이 하나씩 적혀 있고, 좌측 상단 칸 (1행 1열) 에는 말이 놓여 있다.
말은 상하좌우로 인접한 네 칸 중의 한 칸으로 이동할 수 있는데, 새로 이동한 칸에 적혀 있는 알파벳은 지금까지 지나온 모든 칸에 적혀 있는 알파벳과는 달라야 한다. 즉, 같은 알파벳이 적힌 칸을 두 번 지날 수 없다.
좌측 상단에서 시작해서, 말이 최대한 몇 칸을 지날 수 있는지를 구하는 프로그램을 작성하시오. 말이 지나는 칸은 좌측 상단의 칸도 포함된다.
 
입력 - 첫째 줄에 R과 C가 빈칸을 사이에 두고 주어진다. (1 ≤ R,C ≤ 20) 둘째 줄부터 R개의 줄에 걸쳐서 보드에 적혀 있는 C개의 대문자 알파벳들이 빈칸 없이 주어진다.
 
출력 - 첫째 줄에 말이 지날 수 있는 최대의 칸 수를 출력한다.
 
나의 풀이
> ![image](/assets/images/1987.png)

 
핵심 - 
1. DFS와 백트래킹을 함께 사용해서 푸는 것. (백트래킹이라는 것이 생소해서 이걸 알아내는데 몇시간을 허비했다)
2. 사용했던 알파벳을 백트래킹하기 위해서 그래프를 아스키코드로 변환해서 저장한다.
3. 방문여부 리스트도 26개의 ‘0’으로 초기화한다.
4. 방문처리 > DFS 재귀함수 > 백트래킹(방문처리 취소) 순서
 
설명 - 
1. 그래프의 크기 및 strings리스트를 받아온다. strings 리스트는 입력받은 알파베을 숫자로 변환해서 저장한다.
2. 방문처리 리스트 정의한다.
3. 평소 같았으면 dx, dy리스트를 정의하지 않고 재귀함수를 4회 진행했을텐데, 백트래킹을 위해서 dx, dy를 정의해서 사용했다.
4. 시작하는 지점의 방문처리 및 answer = 1로 초기화한다.
 
백트래킹이라는 개념을 몰랐어서 정말 시간이 많이 걸렸던 문제였다. 몇시간이 걸리든 혼자서 풀고, 안되면 다른 사람의 정답을 참고하려는 성격때문에.. 시간이 정말 많이 걸렸다. 개념 자체는 정말 단순한 문제였기 때문에 시간을 허비한 것에 너무 아쉽다.
 
탐색 + 백트래킹은 앞으로 절대 안틀릴것 같다.